<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Document</title>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/addons/p5.dom.min.js"></script>
    <script src="sketch.js"></script>
  </head>
  <body>
    <video
      loop
      muted
      controls
      src="crowd.mp4"
      id="video"
      height="360"
      width="640"
    ></video>

    <script type="text/javascript">
      const NUM_READINGS = 10;
      const VIDEO_WIDTH = 640;
      const VIDEO_HEIGHT = 360;
      let xPreviousAverages = new Array(NUM_READINGS).fill(VIDEO_WIDTH / 2);
      let xRunningTotal = (VIDEO_WIDTH * NUM_READINGS) / 2;
      let yPreviousAverages = new Array(NUM_READINGS).fill(VIDEO_HEIGHT / 2);
      let yRunningTotal = (VIDEO_HEIGHT * NUM_READINGS) / 2;
      let xMinAverages = new Array(NUM_READINGS).fill(0);
      let xMinRunningTotal = 0;
      let yMinAverages = new Array(NUM_READINGS).fill(0);
      let yMinRunningTotal = 0;
      let xMaxAverages = new Array(NUM_READINGS).fill(VIDEO_WIDTH);
      let xMaxRunningTotal = VIDEO_WIDTH * NUM_READINGS;
      let yMaxAverages = new Array(NUM_READINGS).fill(VIDEO_HEIGHT);
      let yMaxRunningTotal = VIDEO_HEIGHT * NUM_READINGS;
      let unityTotal = 0;
      let unityScores = new Array(NUM_READINGS).fill(0);
      let readIndex = 0;

      function getResults(poses) {
        let xTotal = 0;
        let yTotal = 0;
        let xMin = VIDEO_WIDTH;
        let xMax = 0;
        let yMin = VIDEO_HEIGHT;
        let yMax = 0;
        let validPoses = 0;
        poses.forEach((pose) => {
          if (pose.score >= 0.3) {
            validPoses++;
            const { minX, minY, maxX, maxY } = posenet.getBoundingBox(
              pose.keypoints
            );
            const xCenter = minX + (maxX - minX) / 2;
            const yCenter = minY + (maxY - minY) / 2;

            xMin = Math.min(xMin, xCenter);
            xMax = Math.max(xMax, xCenter);
            yMin = Math.min(yMin, yCenter);
            yMax = Math.max(yMax, yCenter);

            xTotal += xCenter;
            yTotal += yCenter;
          }
        });

        const xValid = xTotal / validPoses;
        const yValid = yTotal / validPoses;

        xRunningTotal -= xPreviousAverages[readIndex];
        yRunningTotal -= yPreviousAverages[readIndex];
        xMinRunningTotal -= xMinAverages[readIndex];
        xMaxRunningTotal -= xMaxAverages[readIndex];
        yMinRunningTotal -= yMinAverages[readIndex];
        yMaxRunningTotal -= yMaxAverages[readIndex];
        unityTotal -= unityScores[readIndex];

        xPreviousAverages[readIndex] = xValid;
        yPreviousAverages[readIndex] = yValid;
        xMinAverages[readIndex] = xMin;
        xMaxAverages[readIndex] = xMax;
        yMinAverages[readIndex] = yMin;
        yMaxAverages[readIndex] = yMax;

        xRunningTotal += xPreviousAverages[readIndex];
        yRunningTotal += yPreviousAverages[readIndex];
        xMinRunningTotal += xMinAverages[readIndex];
        xMaxRunningTotal += xMaxAverages[readIndex];
        yMinRunningTotal += yMinAverages[readIndex];
        yMaxRunningTotal += yMaxAverages[readIndex];

        const xAvg = xRunningTotal / NUM_READINGS;
        const yAvg = yRunningTotal / NUM_READINGS;
        const xMinAvg = xMinRunningTotal / NUM_READINGS;
        const xMaxAvg = xMaxRunningTotal / NUM_READINGS;
        const yMinAvg = yMinRunningTotal / NUM_READINGS;
        const yMaxAvg = yMaxRunningTotal / NUM_READINGS;

        const width = xMaxAvg - xMinAvg;
        const height = yMaxAvg - yMinAvg;

        unityScores[readIndex] = 1 - (width * height) / 203400;
        unityTotal += unityScores[readIndex];

        readIndex++;

        if (readIndex >= NUM_READINGS) {
          readIndex = 0;
        }
        // (1 - unity / 230400)
        window.unity = unityTotal / NUM_READINGS;
        // window.unity = 1 - (width * height) / 203400;
        window.xAvg = Math.round(xAvg);
        window.yAvg = Math.round(yAvg);
        window.peopleCount = validPoses;
      }

      const video = document.getElementById("video");

      posenet
        .load({
          architecture: "MobileNetV1",
          outputStride: 16,
          inputResolution: { width: 640, height: 360 },
          multiplier: 0.75,
        })
        .then((net) => {
          console.log("Net loaded");

          video.addEventListener("play", () => {
            setInterval(async () => {
              const poses = await net.estimateMultiplePoses(video, {
                maxDetections: 10,
              });
              getResults(poses);
            }, 100);
          });

          if (video.readyState === 4) {
            video.play();
          } else {
            video.addEventListener("loadeddata", () => {
              video.play();
            });
          }
        });
    </script>
  </body>
</html>
